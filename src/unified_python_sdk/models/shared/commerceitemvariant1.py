"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .commerceitemmedia import CommerceItemMedia, CommerceItemMediaTypedDict
from .commerceitemoption import CommerceItemOption, CommerceItemOptionTypedDict
from .commerceitemprice import CommerceItemPrice, CommerceItemPriceTypedDict
from .commercemetadata import CommerceMetadata, CommerceMetadataTypedDict
from .commercereference import CommerceReference, CommerceReferenceTypedDict
from datetime import datetime
from enum import Enum
from pydantic import field_serializer, model_serializer
from typing import Any, Dict, List, Optional
from typing_extensions import NotRequired, TypedDict
from unified_python_sdk import utils
from unified_python_sdk.models import shared
from unified_python_sdk.types import BaseModel, UNSET_SENTINEL


class CommerceItemvariantSizeUnit(str, Enum, metaclass=utils.OpenEnumMeta):
    CM = "cm"
    INCH = "inch"


class CommerceItemvariantWeightUnit(str, Enum, metaclass=utils.OpenEnumMeta):
    G = "g"
    KG = "kg"
    OZ = "oz"
    LB = "lb"


class CommerceItemvariant1TypedDict(TypedDict):
    available_at: NotRequired[datetime]
    created_at: NotRequired[datetime]
    description: NotRequired[str]
    height: NotRequired[float]
    id: NotRequired[str]
    inventory_id: NotRequired[str]
    is_active: NotRequired[bool]
    is_featured: NotRequired[bool]
    is_visible: NotRequired[bool]
    items: NotRequired[List[CommerceReferenceTypedDict]]
    r"""Reference to CommerceItem"""
    length: NotRequired[float]
    media: NotRequired[List[CommerceItemMediaTypedDict]]
    metadata: NotRequired[List[CommerceMetadataTypedDict]]
    name: NotRequired[str]
    options: NotRequired[List[CommerceItemOptionTypedDict]]
    prices: NotRequired[List[CommerceItemPriceTypedDict]]
    public_description: NotRequired[str]
    public_name: NotRequired[str]
    raw: NotRequired[Dict[str, Any]]
    requires_shipping: NotRequired[bool]
    size_unit: NotRequired[CommerceItemvariantSizeUnit]
    sku: NotRequired[str]
    tags: NotRequired[List[str]]
    total_stock: NotRequired[float]
    updated_at: NotRequired[datetime]
    weight: NotRequired[float]
    weight_unit: NotRequired[CommerceItemvariantWeightUnit]
    width: NotRequired[float]


class CommerceItemvariant1(BaseModel):
    available_at: Optional[datetime] = None

    created_at: Optional[datetime] = None

    description: Optional[str] = None

    height: Optional[float] = None

    id: Optional[str] = None

    inventory_id: Optional[str] = None

    is_active: Optional[bool] = None

    is_featured: Optional[bool] = None

    is_visible: Optional[bool] = None

    items: Optional[List[CommerceReference]] = None
    r"""Reference to CommerceItem"""

    length: Optional[float] = None

    media: Optional[List[CommerceItemMedia]] = None

    metadata: Optional[List[CommerceMetadata]] = None

    name: Optional[str] = None

    options: Optional[List[CommerceItemOption]] = None

    prices: Optional[List[CommerceItemPrice]] = None

    public_description: Optional[str] = None

    public_name: Optional[str] = None

    raw: Optional[Dict[str, Any]] = None

    requires_shipping: Optional[bool] = None

    size_unit: Optional[CommerceItemvariantSizeUnit] = None

    sku: Optional[str] = None

    tags: Optional[List[str]] = None

    total_stock: Optional[float] = None

    updated_at: Optional[datetime] = None

    weight: Optional[float] = None

    weight_unit: Optional[CommerceItemvariantWeightUnit] = None

    width: Optional[float] = None

    @field_serializer("size_unit")
    def serialize_size_unit(self, value):
        if isinstance(value, str):
            try:
                return shared.CommerceItemvariantSizeUnit(value)
            except ValueError:
                return value
        return value

    @field_serializer("weight_unit")
    def serialize_weight_unit(self, value):
        if isinstance(value, str):
            try:
                return shared.CommerceItemvariantWeightUnit(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "available_at",
                "created_at",
                "description",
                "height",
                "id",
                "inventory_id",
                "is_active",
                "is_featured",
                "is_visible",
                "items",
                "length",
                "media",
                "metadata",
                "name",
                "options",
                "prices",
                "public_description",
                "public_name",
                "raw",
                "requires_shipping",
                "size_unit",
                "sku",
                "tags",
                "total_stock",
                "updated_at",
                "weight",
                "weight_unit",
                "width",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
